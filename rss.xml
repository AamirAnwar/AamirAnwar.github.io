<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[The Developer Times]]></title><description><![CDATA[A personal blog]]></description><link>http://thedevelopertimes.in/</link><generator>RSS for Node</generator><lastBuildDate>Thu, 19 Apr 2018 16:28:13 GMT</lastBuildDate><item><title><![CDATA[Sorting Heuristics]]></title><description><![CDATA[About Sorting TL;DR - Get to know the classic sorting algorithms and go write them in your favourite programming language on a whiteboard…]]></description><link>http://thedevelopertimes.in//basic-sorting/</link><guid isPermaLink="false">http://thedevelopertimes.in//basic-sorting/</guid><pubDate>Mon, 16 Apr 2018 16:25:03 GMT</pubDate><content:encoded>&lt;h2&gt;About Sorting&lt;/h2&gt;
&lt;p&gt;TL;DR - Get to know the classic sorting algorithms and go write them in your favourite programming language on a whiteboard.&lt;/p&gt;
&lt;p&gt;Sorting is one of the most fundamental problems that comes up in computing. There are a few classic algorithms which solve this in minimal time, here are a few of them with their running times -&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bubble sort - O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/li&gt;
&lt;li&gt;Insertion sort - O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/li&gt;
&lt;li&gt;Selection sort - O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/li&gt;
&lt;li&gt;Merge sort - O(n*log(n))&lt;/li&gt;
&lt;li&gt;Quick sort - O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Yep you read that right, Quicksort which is widely known as one of the fastest sorting algorithm has a worst case of O(n&lt;sup&gt;2&lt;/sup&gt;). Quicksort gains it’s speed from randomising pivot selection which on average gives the algorithm a better upper bound of O(n*log(n)). Mergesort is great when your input is too big to fit into main memory which does happen time to time. If you see a situation like this, Mergesort is your best friend.&lt;/p&gt;
&lt;p&gt;Bubble sort, Insertion sort and Selection sort have a upper bound of O(n&lt;sup&gt;2&lt;/sup&gt;) which should make you think twice before using them. If your input size is small (around 10 maybe?) these algorithms actually run faster than their superiors. That being said, you can speed these guys up as well if you go ahead and memorize every data structure known to man (I can actually teach you how to do just that. You’ll be a god amongst men. &lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_data_structures&quot;&gt;Here’s a list of them&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Coming back to these algorithms if you used a heap with selection sort you automatically get a boost (actually a downward boost) of running time and go from O(n&lt;sup&gt;2&lt;/sup&gt;) to O(n*log(n)).&lt;/p&gt;
&lt;p&gt;It’s absolutely amazing what you can do to an algorithm if you know your data structures inside out. Another example of this is Kruskals Algorithm for finding the Minimum Spanning Tree in a weighted graph which goes from O(mn) to O(mlog(n)) using a nifty little data structure called the Union-Find data structure (or a Disjoint Set) but we’ll get to these guys in a later post.&lt;/p&gt;
&lt;p&gt;Another word to the wise, it’s not advised to use Quicksort when you don’t have random access capabilities, case in point, a Linked List. If you have to sort a Linked List, first thing is to see if you really really need to use a linked list? If that’s a yes then use Mergesort. Mergesort for linked lists breaks up into two subproblems,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Find the middle of a linked list&lt;/li&gt;
&lt;li&gt;Merge two sorted linked lists in linear time&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you know those two then sorting a Linked List is a piece of cake. But use an array instead if you can. Seriously do that.&lt;/p&gt;
&lt;p&gt;To conclude, if you had to take away one thing from this post it should be that you absolutely need to know you sorting routines inside and out in your favourite programming language. This goes a long way when you need to devise an algorithm which could potentially be a mutation of one of the classic sorts making for an instant win at the workplace.&lt;/p&gt;
&lt;p&gt;I’ll be writing up more posts like this so hit me up on &lt;a href=&quot;https://twitter.com/aamiranwarr&quot;&gt;Twitter&lt;/a&gt; and i’ll sort out any concerns you may have with this. Sorry I just had to put a sorting pun there. Alright bye.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://media.giphy.com/media/AmDzMmCJZABsk/giphy.gif&quot;&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Winter of 17]]></title><description><![CDATA[Source: Unsplash So in the winter of 2017 I started out with a plan to hit the refresh button after developing for iOS for more than a year…]]></description><link>http://thedevelopertimes.in//winter-of-17/</link><guid isPermaLink="false">http://thedevelopertimes.in//winter-of-17/</guid><pubDate>Fri, 01 Dec 2017 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1501159599894-155982264a55?auto=format&amp;#x26;fit=crop&amp;#x26;w=2550&amp;#x26;q=60&amp;#x26;ixid=dW5zcGxhc2guY29tOzs7Ozs%3D&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Source: Unsplash&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So in the winter of 2017 I started out with a plan to hit the refresh button after developing for iOS for more than a year at a technology firm. I wanted to try out new technologies and see what I can do with some free time on my hands, consider it a challenge of sorts. I started off by making apps in Swift and putting them up on the app store, namely, Wordiste and Membermore. Both still a work in progress as they are just the manifestations of the core idea behind making each of them. I do keep updating them from time to time.&lt;/p&gt;
&lt;p&gt;Post this swift development sprint I turned my attention to the holy grail of front end technologies HTML, CSS and Javascript. I picked courses on Udemy and Stackskills and started putting the pieces together however it wasn’t until I started with nodeJS that I really got into it. This blog you’re reading is one of the outcomes of learning these technologies.&lt;/p&gt;
&lt;p&gt;I really did feel the thrill of the challenge and mysteries of the bugs I introduced along with the hidden tricks of these languages and technologies.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://media.giphy.com/media/26FLa6peMp3ZNzKnu/giphy.gif&quot;&gt;&lt;/p&gt;
&lt;p&gt; What’s even more exciting is the fact that there is really no limit to this, which is scary I do admit but I presume that is the thrill of the chase and the challenge of life. Interesting domains such as Machine learning, AI and Deep Learning are what i’ll see to next.
P.S. - I do remain an iOS faithful but it doesn’t hurt to branch out a bit :D&lt;/p&gt;</content:encoded></item></channel></rss>